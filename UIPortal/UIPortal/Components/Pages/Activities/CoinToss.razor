    @page "/activities/coinToss"
    @rendermode InteractiveServer
    @inject HttpClient _httpClient
    @inject NavigationManager NavigationManager
    @using System.Security.Claims;
    @using Microsoft.JSInterop;
    @inject IJSRuntime JS

    <div class="mb-3" id="alocatebalance" style="@((takeBalance) ? "display:block;" : "display:none;")">
        <h3>Enter the balance you want to give</h3>
        <input type="number" @bind="alocatedBalance" placeholder="Enter balance..." class="form-control" />
        <hr />
        <button class="btn btn-primary" @onclick="() => alterBalance()">Give</button>
    </div>

    <div class="card text-center">
        <div class="card-body">
            <h4>@displayedBalance</h4>
        </div>
    </div>

    <div class="d-flex justify-content-center">
        <div class="card text-center" style="width: 18rem;@((takeBalance) ?"display:none;":  "display:block;" ) ">
            <div class="card-body">
                <h5 class="card-title">Choices</h5>
                <h6 class="card-subtitle mb-2 text-muted">@result</h6>
                <p class="card-text">Choose Head or tail</p>
            <button style="@((takeBalance) ?"display:none;":  "display:block;" )">Play Again</button>
                <button class="btn btn-primary" @onclick="() => ChooseOption(1)">Head</button>
                <button class="btn btn-primary" @onclick="() => ChooseOption(2)">Tail</button>
            </div>
        </div>
    </div>

    @code {
        [CascadingParameter]
        private Task<AuthenticationState> authenticationStateTask { get; set; }
        private string result;

        private bool takeBalance = true;
        private int alocatedBalance;
        private int displayedBalance;
        private int customerBalance;
        private int winningBalance;

        private int? identityNum;

        [Inject]
        private IJSRuntime JSRuntime { get; set; }

        protected override async Task OnInitializedAsync()
        {
            var authState = await authenticationStateTask;
            var user = authState.User;
            var idClaim = user.Claims.FirstOrDefault(c => c.Type == ClaimTypes.NameIdentifier);
            if (idClaim != null && int.TryParse(idClaim.Value, out int id))
            {
                identityNum = id;
            }

            if (user.Identity.IsAuthenticated)
            {
                customerBalance = await _httpClient.GetFromJsonAsync<int>($"https://localhost:7011/api/Customers/balance/{identityNum}");
            }
        }

        private async void alterBalance()
        {
            var newBalance = customerBalance - alocatedBalance;
            if (newBalance < 0)
            {
                await JSRuntime.InvokeVoidAsync("alert", "This balance cannot be allocated.");
                NavigationManager.NavigateTo(NavigationManager.Uri, forceLoad: true);
            }
            else
            {
                string apiUrl = $"https://localhost:7011/api/Customers/balanceUpdate/{identityNum}?newBalance={newBalance}";
                // Send a PUT request with an empty content body
                var response = await _httpClient.PutAsync(apiUrl, null);
                if (response.IsSuccessStatusCode)
                {
                    takeBalance = false;
                    displayedBalance = newBalance;
                }
                else
                {
                    await JSRuntime.InvokeVoidAsync("alert", "Failed to update balance.");
                }
            }
        }

        private void ChooseOption(int option)
        {
            var userChoice = option;
            var computerChoice = new Random().Next(1, 3);
            if (userChoice == computerChoice)
            {
                winningBalance = alocatedBalance * 2;
                result = $"You won! {winningBalance}";
            }
            else
            {
                result = "You lost!";
            }
        }
    }
